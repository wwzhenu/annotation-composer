<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInita678904f8c31c7626b9e6d74ce95e694
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        // 若loader已生成，返回此loader  单例模式
        if (null !== self::$loader) {
            return self::$loader;
        }

        // 将ComposerAutoloaderInita678904f8c31c7626b9e6d74ce95e694类中的loadClassLoader注册为 __autoload 的实现
        // 即在遇到未加载的类时，尝试以loadClassLoader方法加载此类
        spl_autoload_register(array('ComposerAutoloaderInita678904f8c31c7626b9e6d74ce95e694', 'loadClassLoader'), true, true);
        // 实例化 ClassLoader，此时ClassLoader尚未加载，调用 loadClassLoader 方法，加载 ClassLoader.php
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        // 注销 ComposerAutoloaderInita678904f8c31c7626b9e6d74ce95e694类中的loadClassLoader方法作为 __autoload的实现
        spl_autoload_unregister(array('ComposerAutoloaderInita678904f8c31c7626b9e6d74ce95e694', 'loadClassLoader'));
        // 上边代码实际上只ClassLoader.php文件加载，为什么不直接 require __DIR__ . '/ClassLoader.php';  ？
        // 为了避免有相同命名空间 Composer\Autoload\ClassLoader  在之后自动加载时加载错误文件

        //5.6版本及以上 未定义HHVM_VERSION  非zend loader文件   加载静态loader  要加载的class中，所有方法都是静态方法
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
        if ($useStaticLoader) {
            require_once __DIR__ . '/autoload_static.php';
            // 初始化loader属性
            // \Composer\Autoload\ComposerStaticInita678904f8c31c7626b9e6d74ce95e694::getInitializer($loader) 返回了一个匿名函数，所以通过call_user_func调用
            // 也可以以如下方式调用： (\Composer\Autoload\ComposerStaticInita678904f8c31c7626b9e6d74ce95e694::getInitializer($loader))()
            // 此匿名函数修改了 $loader中的私有属性  使用了 \Closure::bind以达到修改私有属性的目的
            call_user_func(\Composer\Autoload\ComposerStaticInita678904f8c31c7626b9e6d74ce95e694::getInitializer($loader));
        } else {
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        $loader->register(true);

        return $loader;
    }
}
